/*
 *  MIT License
 *
 *  Copyright (c) 2020-2026 MASES s.r.l.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */

/**************************************************************************************
 * <auto-generated>
 *      This code was generated from a template using JCOReflector v. 1.16.0.0
 * 
 *      Manual changes to this file may cause unexpected behavior in your application.
 *      Manual changes to this file will be overwritten if the code is regenerated.
 * </auto-generated>
 *************************************************************************************/

package system;

import org.mases.jcobridge.*;
import org.mases.jcobridge.netreflection.*;
import java.util.ArrayList;

// Import section
import system.MidpointRounding;
import system.SByte;
import system.Single;
import system.Decimal;
import system.UInt16;
import system.UInt32;
import system.UInt64;


/**
 * The base .NET class managing System.Math, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e.
 * <p>
 * 
 * .NET documentation at <a href="https://docs.microsoft.com/en-us/dotnet/api/System.Math" target="_top">https://docs.microsoft.com/en-us/dotnet/api/System.Math</a>
 * <p>
 *
 * Powered by JCOBridge: more info at <a href="https://www.jcobridge.com" target="_top">https://www.jcobridge.com</a>
 *
 * @author  MASES s.r.l https://masesgroup.com
 * @version 1.16.0.0
 */
public class Math extends NetObject  {
    /**
     * Fully assembly qualified name: System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
     */
    public static final String assemblyFullName = "System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e";
    /**
     * Assembly name: System.Private.CoreLib
     */
    public static final String assemblyShortName = "System.Private.CoreLib";
    /**
     * Qualified class name: System.Math
     */
    public static final String className = "System.Math";
    static JCOBridge bridge = JCOBridgeInstance.getInstance(assemblyFullName);
    /**
     * The type managed from JCOBridge. See {@link JCType}
     */
    public static JCType classType = createType();
    static JCEnum enumInstance = null;
    JCObject classInstance = null;

    static JCType createType() {
        try {
            String classToCreate = className + ", "
                    + (JCOReflector.getUseFullAssemblyName() ? assemblyFullName : assemblyShortName);
            if (JCOReflector.getDebug())
                JCOReflector.writeLog("Creating %s", classToCreate);
            JCType typeCreated = bridge.GetType(classToCreate);
            if (JCOReflector.getDebug())
                JCOReflector.writeLog("Created: %s",
                        (typeCreated != null) ? typeCreated.toString() : "Returned null value");
            return typeCreated;
        } catch (JCException e) {
            JCOReflector.writeLog(e);
            return null;
        }
    }

    void addReference(String ref) throws Throwable {
        try {
            bridge.AddReference(ref);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }
    /**
     * Internal constructor. Use with caution 
     */
    public Math(java.lang.Object instance) throws Throwable {
        super(instance);
        if (instance instanceof JCObject) {
            classInstance = (JCObject) instance;
        } else
            throw new Exception("Cannot manage object, it is not a JCObject");
    }

    public String getJCOAssemblyName() {
        return assemblyFullName;
    }

    public String getJCOClassName() {
        return className;
    }

    public String getJCOObjectName() {
        return className + ", " + (JCOReflector.getUseFullAssemblyName() ? assemblyFullName : assemblyShortName);
    }

    public java.lang.Object getJCOInstance() {
        return classInstance;
    }

    public void setJCOInstance(JCObject instance) {
        classInstance = instance;
        super.setJCOInstance(classInstance);
    }

    public JCType getJCOType() {
        return classType;
    }
    /**
     * Try to cast the {@link IJCOBridgeReflected} instance into {@link Math}, a cast assert is made to check if types are compatible.
     * @param from {@link IJCOBridgeReflected} instance to be casted
     * @return {@link Math} instance
     * @throws java.lang.Throwable in case of error during cast operation
     */
    public static Math cast(IJCOBridgeReflected from) throws Throwable {
        NetType.AssertCast(classType, from);
        return new Math(from.getJCOInstance());
    }

    // Constructors section
    
    public Math() throws Throwable {
    }

    
    // Methods section
    
    public static byte Clamp(byte value, byte min, byte max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value, min, max);
            return (byte)retObjectClamp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportClampError = true;
            java.lang.String retObjectClamp_ToString = retObjectClamp == null ? "null" : retObjectClamp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectClamp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectClampClass = retObjectClamp.getClass();
                    // java.lang.reflect.Method retObjectClampMethod = retObjectClampClass.getMethod("byteValue");
                    // return (byte)retObjectClampMethod.invoke(retObjectClamp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectClampNumber = java.text.NumberFormat.getInstance().parse(retObjectClamp_ToString);
                    return retObjectClampNumber.byteValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportClampError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into byte and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectClamp != null ? retObjectClamp.getClass() : "null", retObjectClamp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportClampError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static byte Max(byte val1, byte val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1, val2);
            return (byte)retObjectMax;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxError = true;
            java.lang.String retObjectMax_ToString = retObjectMax == null ? "null" : retObjectMax.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMax != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxClass = retObjectMax.getClass();
                    // java.lang.reflect.Method retObjectMaxMethod = retObjectMaxClass.getMethod("byteValue");
                    // return (byte)retObjectMaxMethod.invoke(retObjectMax);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxNumber = java.text.NumberFormat.getInstance().parse(retObjectMax_ToString);
                    return retObjectMaxNumber.byteValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into byte and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMax != null ? retObjectMax.getClass() : "null", retObjectMax_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static byte Min(byte val1, byte val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1, val2);
            return (byte)retObjectMin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinError = true;
            java.lang.String retObjectMin_ToString = retObjectMin == null ? "null" : retObjectMin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinClass = retObjectMin.getClass();
                    // java.lang.reflect.Method retObjectMinMethod = retObjectMinClass.getMethod("byteValue");
                    // return (byte)retObjectMinMethod.invoke(retObjectMin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinNumber = java.text.NumberFormat.getInstance().parse(retObjectMin_ToString);
                    return retObjectMinNumber.byteValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into byte and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMin != null ? retObjectMin.getClass() : "null", retObjectMin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Abs(double value) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value);
            return (double)retObjectAbs;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAbsError = true;
            java.lang.String retObjectAbs_ToString = retObjectAbs == null ? "null" : retObjectAbs.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAbs != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAbsClass = retObjectAbs.getClass();
                    // java.lang.reflect.Method retObjectAbsMethod = retObjectAbsClass.getMethod("doubleValue");
                    // return (double)retObjectAbsMethod.invoke(retObjectAbs);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAbsNumber = java.text.NumberFormat.getInstance().parse(retObjectAbs_ToString);
                    return retObjectAbsNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAbsError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAbs != null ? retObjectAbs.getClass() : "null", retObjectAbs_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAbsError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Acos(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAcos = null;
        try {
            retObjectAcos = classType.Invoke("Acos", d);
            return (double)retObjectAcos;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAcosError = true;
            java.lang.String retObjectAcos_ToString = retObjectAcos == null ? "null" : retObjectAcos.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAcos != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAcosClass = retObjectAcos.getClass();
                    // java.lang.reflect.Method retObjectAcosMethod = retObjectAcosClass.getMethod("doubleValue");
                    // return (double)retObjectAcosMethod.invoke(retObjectAcos);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAcosNumber = java.text.NumberFormat.getInstance().parse(retObjectAcos_ToString);
                    return retObjectAcosNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAcosError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAcos != null ? retObjectAcos.getClass() : "null", retObjectAcos_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAcosError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Acosh(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAcosh = null;
        try {
            retObjectAcosh = classType.Invoke("Acosh", d);
            return (double)retObjectAcosh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAcoshError = true;
            java.lang.String retObjectAcosh_ToString = retObjectAcosh == null ? "null" : retObjectAcosh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAcosh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAcoshClass = retObjectAcosh.getClass();
                    // java.lang.reflect.Method retObjectAcoshMethod = retObjectAcoshClass.getMethod("doubleValue");
                    // return (double)retObjectAcoshMethod.invoke(retObjectAcosh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAcoshNumber = java.text.NumberFormat.getInstance().parse(retObjectAcosh_ToString);
                    return retObjectAcoshNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAcoshError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAcosh != null ? retObjectAcosh.getClass() : "null", retObjectAcosh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAcoshError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Asin(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAsin = null;
        try {
            retObjectAsin = classType.Invoke("Asin", d);
            return (double)retObjectAsin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAsinError = true;
            java.lang.String retObjectAsin_ToString = retObjectAsin == null ? "null" : retObjectAsin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAsin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAsinClass = retObjectAsin.getClass();
                    // java.lang.reflect.Method retObjectAsinMethod = retObjectAsinClass.getMethod("doubleValue");
                    // return (double)retObjectAsinMethod.invoke(retObjectAsin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAsinNumber = java.text.NumberFormat.getInstance().parse(retObjectAsin_ToString);
                    return retObjectAsinNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAsinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAsin != null ? retObjectAsin.getClass() : "null", retObjectAsin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAsinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Asinh(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAsinh = null;
        try {
            retObjectAsinh = classType.Invoke("Asinh", d);
            return (double)retObjectAsinh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAsinhError = true;
            java.lang.String retObjectAsinh_ToString = retObjectAsinh == null ? "null" : retObjectAsinh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAsinh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAsinhClass = retObjectAsinh.getClass();
                    // java.lang.reflect.Method retObjectAsinhMethod = retObjectAsinhClass.getMethod("doubleValue");
                    // return (double)retObjectAsinhMethod.invoke(retObjectAsinh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAsinhNumber = java.text.NumberFormat.getInstance().parse(retObjectAsinh_ToString);
                    return retObjectAsinhNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAsinhError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAsinh != null ? retObjectAsinh.getClass() : "null", retObjectAsinh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAsinhError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Atan(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAtan = null;
        try {
            retObjectAtan = classType.Invoke("Atan", d);
            return (double)retObjectAtan;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAtanError = true;
            java.lang.String retObjectAtan_ToString = retObjectAtan == null ? "null" : retObjectAtan.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAtan != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAtanClass = retObjectAtan.getClass();
                    // java.lang.reflect.Method retObjectAtanMethod = retObjectAtanClass.getMethod("doubleValue");
                    // return (double)retObjectAtanMethod.invoke(retObjectAtan);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAtanNumber = java.text.NumberFormat.getInstance().parse(retObjectAtan_ToString);
                    return retObjectAtanNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAtanError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAtan != null ? retObjectAtan.getClass() : "null", retObjectAtan_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAtanError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Atan2(double y, double x) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAtan2 = null;
        try {
            retObjectAtan2 = classType.Invoke("Atan2", y, x);
            return (double)retObjectAtan2;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAtan2Error = true;
            java.lang.String retObjectAtan2_ToString = retObjectAtan2 == null ? "null" : retObjectAtan2.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAtan2 != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAtan2Class = retObjectAtan2.getClass();
                    // java.lang.reflect.Method retObjectAtan2Method = retObjectAtan2Class.getMethod("doubleValue");
                    // return (double)retObjectAtan2Method.invoke(retObjectAtan2);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAtan2Number = java.text.NumberFormat.getInstance().parse(retObjectAtan2_ToString);
                    return retObjectAtan2Number.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAtan2Error = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAtan2 != null ? retObjectAtan2.getClass() : "null", retObjectAtan2_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAtan2Error) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Atanh(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAtanh = null;
        try {
            retObjectAtanh = classType.Invoke("Atanh", d);
            return (double)retObjectAtanh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAtanhError = true;
            java.lang.String retObjectAtanh_ToString = retObjectAtanh == null ? "null" : retObjectAtanh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAtanh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAtanhClass = retObjectAtanh.getClass();
                    // java.lang.reflect.Method retObjectAtanhMethod = retObjectAtanhClass.getMethod("doubleValue");
                    // return (double)retObjectAtanhMethod.invoke(retObjectAtanh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAtanhNumber = java.text.NumberFormat.getInstance().parse(retObjectAtanh_ToString);
                    return retObjectAtanhNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAtanhError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAtanh != null ? retObjectAtanh.getClass() : "null", retObjectAtanh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAtanhError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double BitDecrement(double x) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectBitDecrement = null;
        try {
            retObjectBitDecrement = classType.Invoke("BitDecrement", x);
            return (double)retObjectBitDecrement;
        } catch (java.lang.ClassCastException cce) {
            boolean reportBitDecrementError = true;
            java.lang.String retObjectBitDecrement_ToString = retObjectBitDecrement == null ? "null" : retObjectBitDecrement.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectBitDecrement != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectBitDecrementClass = retObjectBitDecrement.getClass();
                    // java.lang.reflect.Method retObjectBitDecrementMethod = retObjectBitDecrementClass.getMethod("doubleValue");
                    // return (double)retObjectBitDecrementMethod.invoke(retObjectBitDecrement);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectBitDecrementNumber = java.text.NumberFormat.getInstance().parse(retObjectBitDecrement_ToString);
                    return retObjectBitDecrementNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportBitDecrementError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectBitDecrement != null ? retObjectBitDecrement.getClass() : "null", retObjectBitDecrement_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportBitDecrementError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double BitIncrement(double x) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectBitIncrement = null;
        try {
            retObjectBitIncrement = classType.Invoke("BitIncrement", x);
            return (double)retObjectBitIncrement;
        } catch (java.lang.ClassCastException cce) {
            boolean reportBitIncrementError = true;
            java.lang.String retObjectBitIncrement_ToString = retObjectBitIncrement == null ? "null" : retObjectBitIncrement.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectBitIncrement != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectBitIncrementClass = retObjectBitIncrement.getClass();
                    // java.lang.reflect.Method retObjectBitIncrementMethod = retObjectBitIncrementClass.getMethod("doubleValue");
                    // return (double)retObjectBitIncrementMethod.invoke(retObjectBitIncrement);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectBitIncrementNumber = java.text.NumberFormat.getInstance().parse(retObjectBitIncrement_ToString);
                    return retObjectBitIncrementNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportBitIncrementError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectBitIncrement != null ? retObjectBitIncrement.getClass() : "null", retObjectBitIncrement_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportBitIncrementError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Cbrt(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCbrt = null;
        try {
            retObjectCbrt = classType.Invoke("Cbrt", d);
            return (double)retObjectCbrt;
        } catch (java.lang.ClassCastException cce) {
            boolean reportCbrtError = true;
            java.lang.String retObjectCbrt_ToString = retObjectCbrt == null ? "null" : retObjectCbrt.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectCbrt != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectCbrtClass = retObjectCbrt.getClass();
                    // java.lang.reflect.Method retObjectCbrtMethod = retObjectCbrtClass.getMethod("doubleValue");
                    // return (double)retObjectCbrtMethod.invoke(retObjectCbrt);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectCbrtNumber = java.text.NumberFormat.getInstance().parse(retObjectCbrt_ToString);
                    return retObjectCbrtNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportCbrtError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectCbrt != null ? retObjectCbrt.getClass() : "null", retObjectCbrt_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportCbrtError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Ceiling(double a) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCeiling = null;
        try {
            retObjectCeiling = classType.Invoke("Ceiling", a);
            return (double)retObjectCeiling;
        } catch (java.lang.ClassCastException cce) {
            boolean reportCeilingError = true;
            java.lang.String retObjectCeiling_ToString = retObjectCeiling == null ? "null" : retObjectCeiling.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectCeiling != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectCeilingClass = retObjectCeiling.getClass();
                    // java.lang.reflect.Method retObjectCeilingMethod = retObjectCeilingClass.getMethod("doubleValue");
                    // return (double)retObjectCeilingMethod.invoke(retObjectCeiling);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectCeilingNumber = java.text.NumberFormat.getInstance().parse(retObjectCeiling_ToString);
                    return retObjectCeilingNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportCeilingError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectCeiling != null ? retObjectCeiling.getClass() : "null", retObjectCeiling_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportCeilingError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Clamp(double value, double min, double max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value, min, max);
            return (double)retObjectClamp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportClampError = true;
            java.lang.String retObjectClamp_ToString = retObjectClamp == null ? "null" : retObjectClamp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectClamp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectClampClass = retObjectClamp.getClass();
                    // java.lang.reflect.Method retObjectClampMethod = retObjectClampClass.getMethod("doubleValue");
                    // return (double)retObjectClampMethod.invoke(retObjectClamp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectClampNumber = java.text.NumberFormat.getInstance().parse(retObjectClamp_ToString);
                    return retObjectClampNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportClampError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectClamp != null ? retObjectClamp.getClass() : "null", retObjectClamp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportClampError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double CopySign(double x, double y) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCopySign = null;
        try {
            retObjectCopySign = classType.Invoke("CopySign", x, y);
            return (double)retObjectCopySign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportCopySignError = true;
            java.lang.String retObjectCopySign_ToString = retObjectCopySign == null ? "null" : retObjectCopySign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectCopySign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectCopySignClass = retObjectCopySign.getClass();
                    // java.lang.reflect.Method retObjectCopySignMethod = retObjectCopySignClass.getMethod("doubleValue");
                    // return (double)retObjectCopySignMethod.invoke(retObjectCopySign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectCopySignNumber = java.text.NumberFormat.getInstance().parse(retObjectCopySign_ToString);
                    return retObjectCopySignNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportCopySignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectCopySign != null ? retObjectCopySign.getClass() : "null", retObjectCopySign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportCopySignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Cos(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCos = null;
        try {
            retObjectCos = classType.Invoke("Cos", d);
            return (double)retObjectCos;
        } catch (java.lang.ClassCastException cce) {
            boolean reportCosError = true;
            java.lang.String retObjectCos_ToString = retObjectCos == null ? "null" : retObjectCos.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectCos != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectCosClass = retObjectCos.getClass();
                    // java.lang.reflect.Method retObjectCosMethod = retObjectCosClass.getMethod("doubleValue");
                    // return (double)retObjectCosMethod.invoke(retObjectCos);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectCosNumber = java.text.NumberFormat.getInstance().parse(retObjectCos_ToString);
                    return retObjectCosNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportCosError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectCos != null ? retObjectCos.getClass() : "null", retObjectCos_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportCosError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Cosh(double value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCosh = null;
        try {
            retObjectCosh = classType.Invoke("Cosh", value);
            return (double)retObjectCosh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportCoshError = true;
            java.lang.String retObjectCosh_ToString = retObjectCosh == null ? "null" : retObjectCosh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectCosh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectCoshClass = retObjectCosh.getClass();
                    // java.lang.reflect.Method retObjectCoshMethod = retObjectCoshClass.getMethod("doubleValue");
                    // return (double)retObjectCoshMethod.invoke(retObjectCosh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectCoshNumber = java.text.NumberFormat.getInstance().parse(retObjectCosh_ToString);
                    return retObjectCoshNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportCoshError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectCosh != null ? retObjectCosh.getClass() : "null", retObjectCosh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportCoshError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Exp(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectExp = null;
        try {
            retObjectExp = classType.Invoke("Exp", d);
            return (double)retObjectExp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportExpError = true;
            java.lang.String retObjectExp_ToString = retObjectExp == null ? "null" : retObjectExp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectExp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectExpClass = retObjectExp.getClass();
                    // java.lang.reflect.Method retObjectExpMethod = retObjectExpClass.getMethod("doubleValue");
                    // return (double)retObjectExpMethod.invoke(retObjectExp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectExpNumber = java.text.NumberFormat.getInstance().parse(retObjectExp_ToString);
                    return retObjectExpNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportExpError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectExp != null ? retObjectExp.getClass() : "null", retObjectExp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportExpError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Floor(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectFloor = null;
        try {
            retObjectFloor = classType.Invoke("Floor", d);
            return (double)retObjectFloor;
        } catch (java.lang.ClassCastException cce) {
            boolean reportFloorError = true;
            java.lang.String retObjectFloor_ToString = retObjectFloor == null ? "null" : retObjectFloor.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectFloor != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectFloorClass = retObjectFloor.getClass();
                    // java.lang.reflect.Method retObjectFloorMethod = retObjectFloorClass.getMethod("doubleValue");
                    // return (double)retObjectFloorMethod.invoke(retObjectFloor);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectFloorNumber = java.text.NumberFormat.getInstance().parse(retObjectFloor_ToString);
                    return retObjectFloorNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportFloorError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectFloor != null ? retObjectFloor.getClass() : "null", retObjectFloor_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportFloorError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double FusedMultiplyAdd(double x, double y, double z) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectFusedMultiplyAdd = null;
        try {
            retObjectFusedMultiplyAdd = classType.Invoke("FusedMultiplyAdd", x, y, z);
            return (double)retObjectFusedMultiplyAdd;
        } catch (java.lang.ClassCastException cce) {
            boolean reportFusedMultiplyAddError = true;
            java.lang.String retObjectFusedMultiplyAdd_ToString = retObjectFusedMultiplyAdd == null ? "null" : retObjectFusedMultiplyAdd.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectFusedMultiplyAdd != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectFusedMultiplyAddClass = retObjectFusedMultiplyAdd.getClass();
                    // java.lang.reflect.Method retObjectFusedMultiplyAddMethod = retObjectFusedMultiplyAddClass.getMethod("doubleValue");
                    // return (double)retObjectFusedMultiplyAddMethod.invoke(retObjectFusedMultiplyAdd);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectFusedMultiplyAddNumber = java.text.NumberFormat.getInstance().parse(retObjectFusedMultiplyAdd_ToString);
                    return retObjectFusedMultiplyAddNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportFusedMultiplyAddError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectFusedMultiplyAdd != null ? retObjectFusedMultiplyAdd.getClass() : "null", retObjectFusedMultiplyAdd_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportFusedMultiplyAddError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double IEEERemainder(double x, double y) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException, system.ArithmeticException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectIEEERemainder = null;
        try {
            retObjectIEEERemainder = classType.Invoke("IEEERemainder", x, y);
            return (double)retObjectIEEERemainder;
        } catch (java.lang.ClassCastException cce) {
            boolean reportIEEERemainderError = true;
            java.lang.String retObjectIEEERemainder_ToString = retObjectIEEERemainder == null ? "null" : retObjectIEEERemainder.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectIEEERemainder != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectIEEERemainderClass = retObjectIEEERemainder.getClass();
                    // java.lang.reflect.Method retObjectIEEERemainderMethod = retObjectIEEERemainderClass.getMethod("doubleValue");
                    // return (double)retObjectIEEERemainderMethod.invoke(retObjectIEEERemainder);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectIEEERemainderNumber = java.text.NumberFormat.getInstance().parse(retObjectIEEERemainder_ToString);
                    return retObjectIEEERemainderNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportIEEERemainderError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectIEEERemainder != null ? retObjectIEEERemainder.getClass() : "null", retObjectIEEERemainder_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportIEEERemainderError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Log(double a, double newBase) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectLog = null;
        try {
            retObjectLog = classType.Invoke("Log", a, newBase);
            return (double)retObjectLog;
        } catch (java.lang.ClassCastException cce) {
            boolean reportLogError = true;
            java.lang.String retObjectLog_ToString = retObjectLog == null ? "null" : retObjectLog.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectLog != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectLogClass = retObjectLog.getClass();
                    // java.lang.reflect.Method retObjectLogMethod = retObjectLogClass.getMethod("doubleValue");
                    // return (double)retObjectLogMethod.invoke(retObjectLog);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectLogNumber = java.text.NumberFormat.getInstance().parse(retObjectLog_ToString);
                    return retObjectLogNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportLogError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectLog != null ? retObjectLog.getClass() : "null", retObjectLog_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportLogError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Log(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectLog = null;
        try {
            retObjectLog = classType.Invoke("Log", d);
            return (double)retObjectLog;
        } catch (java.lang.ClassCastException cce) {
            boolean reportLogError = true;
            java.lang.String retObjectLog_ToString = retObjectLog == null ? "null" : retObjectLog.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectLog != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectLogClass = retObjectLog.getClass();
                    // java.lang.reflect.Method retObjectLogMethod = retObjectLogClass.getMethod("doubleValue");
                    // return (double)retObjectLogMethod.invoke(retObjectLog);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectLogNumber = java.text.NumberFormat.getInstance().parse(retObjectLog_ToString);
                    return retObjectLogNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportLogError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectLog != null ? retObjectLog.getClass() : "null", retObjectLog_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportLogError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Log10(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectLog10 = null;
        try {
            retObjectLog10 = classType.Invoke("Log10", d);
            return (double)retObjectLog10;
        } catch (java.lang.ClassCastException cce) {
            boolean reportLog10Error = true;
            java.lang.String retObjectLog10_ToString = retObjectLog10 == null ? "null" : retObjectLog10.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectLog10 != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectLog10Class = retObjectLog10.getClass();
                    // java.lang.reflect.Method retObjectLog10Method = retObjectLog10Class.getMethod("doubleValue");
                    // return (double)retObjectLog10Method.invoke(retObjectLog10);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectLog10Number = java.text.NumberFormat.getInstance().parse(retObjectLog10_ToString);
                    return retObjectLog10Number.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportLog10Error = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectLog10 != null ? retObjectLog10.getClass() : "null", retObjectLog10_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportLog10Error) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Log2(double x) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectLog2 = null;
        try {
            retObjectLog2 = classType.Invoke("Log2", x);
            return (double)retObjectLog2;
        } catch (java.lang.ClassCastException cce) {
            boolean reportLog2Error = true;
            java.lang.String retObjectLog2_ToString = retObjectLog2 == null ? "null" : retObjectLog2.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectLog2 != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectLog2Class = retObjectLog2.getClass();
                    // java.lang.reflect.Method retObjectLog2Method = retObjectLog2Class.getMethod("doubleValue");
                    // return (double)retObjectLog2Method.invoke(retObjectLog2);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectLog2Number = java.text.NumberFormat.getInstance().parse(retObjectLog2_ToString);
                    return retObjectLog2Number.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportLog2Error = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectLog2 != null ? retObjectLog2.getClass() : "null", retObjectLog2_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportLog2Error) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Max(double val1, double val2) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1, val2);
            return (double)retObjectMax;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxError = true;
            java.lang.String retObjectMax_ToString = retObjectMax == null ? "null" : retObjectMax.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMax != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxClass = retObjectMax.getClass();
                    // java.lang.reflect.Method retObjectMaxMethod = retObjectMaxClass.getMethod("doubleValue");
                    // return (double)retObjectMaxMethod.invoke(retObjectMax);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxNumber = java.text.NumberFormat.getInstance().parse(retObjectMax_ToString);
                    return retObjectMaxNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMax != null ? retObjectMax.getClass() : "null", retObjectMax_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double MaxMagnitude(double x, double y) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMaxMagnitude = null;
        try {
            retObjectMaxMagnitude = classType.Invoke("MaxMagnitude", x, y);
            return (double)retObjectMaxMagnitude;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxMagnitudeError = true;
            java.lang.String retObjectMaxMagnitude_ToString = retObjectMaxMagnitude == null ? "null" : retObjectMaxMagnitude.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMaxMagnitude != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxMagnitudeClass = retObjectMaxMagnitude.getClass();
                    // java.lang.reflect.Method retObjectMaxMagnitudeMethod = retObjectMaxMagnitudeClass.getMethod("doubleValue");
                    // return (double)retObjectMaxMagnitudeMethod.invoke(retObjectMaxMagnitude);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxMagnitudeNumber = java.text.NumberFormat.getInstance().parse(retObjectMaxMagnitude_ToString);
                    return retObjectMaxMagnitudeNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxMagnitudeError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMaxMagnitude != null ? retObjectMaxMagnitude.getClass() : "null", retObjectMaxMagnitude_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxMagnitudeError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Min(double val1, double val2) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1, val2);
            return (double)retObjectMin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinError = true;
            java.lang.String retObjectMin_ToString = retObjectMin == null ? "null" : retObjectMin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinClass = retObjectMin.getClass();
                    // java.lang.reflect.Method retObjectMinMethod = retObjectMinClass.getMethod("doubleValue");
                    // return (double)retObjectMinMethod.invoke(retObjectMin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinNumber = java.text.NumberFormat.getInstance().parse(retObjectMin_ToString);
                    return retObjectMinNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMin != null ? retObjectMin.getClass() : "null", retObjectMin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double MinMagnitude(double x, double y) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMinMagnitude = null;
        try {
            retObjectMinMagnitude = classType.Invoke("MinMagnitude", x, y);
            return (double)retObjectMinMagnitude;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinMagnitudeError = true;
            java.lang.String retObjectMinMagnitude_ToString = retObjectMinMagnitude == null ? "null" : retObjectMinMagnitude.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMinMagnitude != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinMagnitudeClass = retObjectMinMagnitude.getClass();
                    // java.lang.reflect.Method retObjectMinMagnitudeMethod = retObjectMinMagnitudeClass.getMethod("doubleValue");
                    // return (double)retObjectMinMagnitudeMethod.invoke(retObjectMinMagnitude);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinMagnitudeNumber = java.text.NumberFormat.getInstance().parse(retObjectMinMagnitude_ToString);
                    return retObjectMinMagnitudeNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinMagnitudeError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMinMagnitude != null ? retObjectMinMagnitude.getClass() : "null", retObjectMinMagnitude_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinMagnitudeError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Pow(double x, double y) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectPow = null;
        try {
            retObjectPow = classType.Invoke("Pow", x, y);
            return (double)retObjectPow;
        } catch (java.lang.ClassCastException cce) {
            boolean reportPowError = true;
            java.lang.String retObjectPow_ToString = retObjectPow == null ? "null" : retObjectPow.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectPow != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectPowClass = retObjectPow.getClass();
                    // java.lang.reflect.Method retObjectPowMethod = retObjectPowClass.getMethod("doubleValue");
                    // return (double)retObjectPowMethod.invoke(retObjectPow);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectPowNumber = java.text.NumberFormat.getInstance().parse(retObjectPow_ToString);
                    return retObjectPowNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportPowError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectPow != null ? retObjectPow.getClass() : "null", retObjectPow_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportPowError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double ReciprocalEstimate(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectReciprocalEstimate = null;
        try {
            retObjectReciprocalEstimate = classType.Invoke("ReciprocalEstimate", d);
            return (double)retObjectReciprocalEstimate;
        } catch (java.lang.ClassCastException cce) {
            boolean reportReciprocalEstimateError = true;
            java.lang.String retObjectReciprocalEstimate_ToString = retObjectReciprocalEstimate == null ? "null" : retObjectReciprocalEstimate.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectReciprocalEstimate != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectReciprocalEstimateClass = retObjectReciprocalEstimate.getClass();
                    // java.lang.reflect.Method retObjectReciprocalEstimateMethod = retObjectReciprocalEstimateClass.getMethod("doubleValue");
                    // return (double)retObjectReciprocalEstimateMethod.invoke(retObjectReciprocalEstimate);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectReciprocalEstimateNumber = java.text.NumberFormat.getInstance().parse(retObjectReciprocalEstimate_ToString);
                    return retObjectReciprocalEstimateNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportReciprocalEstimateError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectReciprocalEstimate != null ? retObjectReciprocalEstimate.getClass() : "null", retObjectReciprocalEstimate_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportReciprocalEstimateError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double ReciprocalSqrtEstimate(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectReciprocalSqrtEstimate = null;
        try {
            retObjectReciprocalSqrtEstimate = classType.Invoke("ReciprocalSqrtEstimate", d);
            return (double)retObjectReciprocalSqrtEstimate;
        } catch (java.lang.ClassCastException cce) {
            boolean reportReciprocalSqrtEstimateError = true;
            java.lang.String retObjectReciprocalSqrtEstimate_ToString = retObjectReciprocalSqrtEstimate == null ? "null" : retObjectReciprocalSqrtEstimate.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectReciprocalSqrtEstimate != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectReciprocalSqrtEstimateClass = retObjectReciprocalSqrtEstimate.getClass();
                    // java.lang.reflect.Method retObjectReciprocalSqrtEstimateMethod = retObjectReciprocalSqrtEstimateClass.getMethod("doubleValue");
                    // return (double)retObjectReciprocalSqrtEstimateMethod.invoke(retObjectReciprocalSqrtEstimate);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectReciprocalSqrtEstimateNumber = java.text.NumberFormat.getInstance().parse(retObjectReciprocalSqrtEstimate_ToString);
                    return retObjectReciprocalSqrtEstimateNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportReciprocalSqrtEstimateError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectReciprocalSqrtEstimate != null ? retObjectReciprocalSqrtEstimate.getClass() : "null", retObjectReciprocalSqrtEstimate_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportReciprocalSqrtEstimateError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Round(double value, int digits, MidpointRounding mode) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.IndexOutOfRangeException, system.RankException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", value, digits, mode == null ? null : mode.getJCOInstance());
            return (double)retObjectRound;
        } catch (java.lang.ClassCastException cce) {
            boolean reportRoundError = true;
            java.lang.String retObjectRound_ToString = retObjectRound == null ? "null" : retObjectRound.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectRound != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectRoundClass = retObjectRound.getClass();
                    // java.lang.reflect.Method retObjectRoundMethod = retObjectRoundClass.getMethod("doubleValue");
                    // return (double)retObjectRoundMethod.invoke(retObjectRound);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectRoundNumber = java.text.NumberFormat.getInstance().parse(retObjectRound_ToString);
                    return retObjectRoundNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportRoundError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectRound != null ? retObjectRound.getClass() : "null", retObjectRound_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportRoundError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Round(double value, int digits) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", value, digits);
            return (double)retObjectRound;
        } catch (java.lang.ClassCastException cce) {
            boolean reportRoundError = true;
            java.lang.String retObjectRound_ToString = retObjectRound == null ? "null" : retObjectRound.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectRound != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectRoundClass = retObjectRound.getClass();
                    // java.lang.reflect.Method retObjectRoundMethod = retObjectRoundClass.getMethod("doubleValue");
                    // return (double)retObjectRoundMethod.invoke(retObjectRound);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectRoundNumber = java.text.NumberFormat.getInstance().parse(retObjectRound_ToString);
                    return retObjectRoundNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportRoundError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectRound != null ? retObjectRound.getClass() : "null", retObjectRound_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportRoundError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Round(double value, MidpointRounding mode) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", value, mode == null ? null : mode.getJCOInstance());
            return (double)retObjectRound;
        } catch (java.lang.ClassCastException cce) {
            boolean reportRoundError = true;
            java.lang.String retObjectRound_ToString = retObjectRound == null ? "null" : retObjectRound.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectRound != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectRoundClass = retObjectRound.getClass();
                    // java.lang.reflect.Method retObjectRoundMethod = retObjectRoundClass.getMethod("doubleValue");
                    // return (double)retObjectRoundMethod.invoke(retObjectRound);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectRoundNumber = java.text.NumberFormat.getInstance().parse(retObjectRound_ToString);
                    return retObjectRoundNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportRoundError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectRound != null ? retObjectRound.getClass() : "null", retObjectRound_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportRoundError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Round(double a) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", a);
            return (double)retObjectRound;
        } catch (java.lang.ClassCastException cce) {
            boolean reportRoundError = true;
            java.lang.String retObjectRound_ToString = retObjectRound == null ? "null" : retObjectRound.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectRound != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectRoundClass = retObjectRound.getClass();
                    // java.lang.reflect.Method retObjectRoundMethod = retObjectRoundClass.getMethod("doubleValue");
                    // return (double)retObjectRoundMethod.invoke(retObjectRound);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectRoundNumber = java.text.NumberFormat.getInstance().parse(retObjectRound_ToString);
                    return retObjectRoundNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportRoundError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectRound != null ? retObjectRound.getClass() : "null", retObjectRound_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportRoundError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double ScaleB(double x, int n) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectScaleB = null;
        try {
            retObjectScaleB = classType.Invoke("ScaleB", x, n);
            return (double)retObjectScaleB;
        } catch (java.lang.ClassCastException cce) {
            boolean reportScaleBError = true;
            java.lang.String retObjectScaleB_ToString = retObjectScaleB == null ? "null" : retObjectScaleB.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectScaleB != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectScaleBClass = retObjectScaleB.getClass();
                    // java.lang.reflect.Method retObjectScaleBMethod = retObjectScaleBClass.getMethod("doubleValue");
                    // return (double)retObjectScaleBMethod.invoke(retObjectScaleB);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectScaleBNumber = java.text.NumberFormat.getInstance().parse(retObjectScaleB_ToString);
                    return retObjectScaleBNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportScaleBError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectScaleB != null ? retObjectScaleB.getClass() : "null", retObjectScaleB_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportScaleBError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Sin(double a) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSin = null;
        try {
            retObjectSin = classType.Invoke("Sin", a);
            return (double)retObjectSin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSinError = true;
            java.lang.String retObjectSin_ToString = retObjectSin == null ? "null" : retObjectSin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSinClass = retObjectSin.getClass();
                    // java.lang.reflect.Method retObjectSinMethod = retObjectSinClass.getMethod("doubleValue");
                    // return (double)retObjectSinMethod.invoke(retObjectSin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSinNumber = java.text.NumberFormat.getInstance().parse(retObjectSin_ToString);
                    return retObjectSinNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSin != null ? retObjectSin.getClass() : "null", retObjectSin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Sinh(double value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSinh = null;
        try {
            retObjectSinh = classType.Invoke("Sinh", value);
            return (double)retObjectSinh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSinhError = true;
            java.lang.String retObjectSinh_ToString = retObjectSinh == null ? "null" : retObjectSinh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSinh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSinhClass = retObjectSinh.getClass();
                    // java.lang.reflect.Method retObjectSinhMethod = retObjectSinhClass.getMethod("doubleValue");
                    // return (double)retObjectSinhMethod.invoke(retObjectSinh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSinhNumber = java.text.NumberFormat.getInstance().parse(retObjectSinh_ToString);
                    return retObjectSinhNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSinhError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSinh != null ? retObjectSinh.getClass() : "null", retObjectSinh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSinhError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Sqrt(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSqrt = null;
        try {
            retObjectSqrt = classType.Invoke("Sqrt", d);
            return (double)retObjectSqrt;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSqrtError = true;
            java.lang.String retObjectSqrt_ToString = retObjectSqrt == null ? "null" : retObjectSqrt.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSqrt != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSqrtClass = retObjectSqrt.getClass();
                    // java.lang.reflect.Method retObjectSqrtMethod = retObjectSqrtClass.getMethod("doubleValue");
                    // return (double)retObjectSqrtMethod.invoke(retObjectSqrt);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSqrtNumber = java.text.NumberFormat.getInstance().parse(retObjectSqrt_ToString);
                    return retObjectSqrtNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSqrtError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSqrt != null ? retObjectSqrt.getClass() : "null", retObjectSqrt_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSqrtError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Tan(double a) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectTan = null;
        try {
            retObjectTan = classType.Invoke("Tan", a);
            return (double)retObjectTan;
        } catch (java.lang.ClassCastException cce) {
            boolean reportTanError = true;
            java.lang.String retObjectTan_ToString = retObjectTan == null ? "null" : retObjectTan.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectTan != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectTanClass = retObjectTan.getClass();
                    // java.lang.reflect.Method retObjectTanMethod = retObjectTanClass.getMethod("doubleValue");
                    // return (double)retObjectTanMethod.invoke(retObjectTan);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectTanNumber = java.text.NumberFormat.getInstance().parse(retObjectTan_ToString);
                    return retObjectTanNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportTanError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectTan != null ? retObjectTan.getClass() : "null", retObjectTan_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportTanError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Tanh(double value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectTanh = null;
        try {
            retObjectTanh = classType.Invoke("Tanh", value);
            return (double)retObjectTanh;
        } catch (java.lang.ClassCastException cce) {
            boolean reportTanhError = true;
            java.lang.String retObjectTanh_ToString = retObjectTanh == null ? "null" : retObjectTanh.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectTanh != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectTanhClass = retObjectTanh.getClass();
                    // java.lang.reflect.Method retObjectTanhMethod = retObjectTanhClass.getMethod("doubleValue");
                    // return (double)retObjectTanhMethod.invoke(retObjectTanh);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectTanhNumber = java.text.NumberFormat.getInstance().parse(retObjectTanh_ToString);
                    return retObjectTanhNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportTanhError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectTanh != null ? retObjectTanh.getClass() : "null", retObjectTanh_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportTanhError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static double Truncate(double d) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectTruncate = null;
        try {
            retObjectTruncate = classType.Invoke("Truncate", d);
            return (double)retObjectTruncate;
        } catch (java.lang.ClassCastException cce) {
            boolean reportTruncateError = true;
            java.lang.String retObjectTruncate_ToString = retObjectTruncate == null ? "null" : retObjectTruncate.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectTruncate != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectTruncateClass = retObjectTruncate.getClass();
                    // java.lang.reflect.Method retObjectTruncateMethod = retObjectTruncateClass.getMethod("doubleValue");
                    // return (double)retObjectTruncateMethod.invoke(retObjectTruncate);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectTruncateNumber = java.text.NumberFormat.getInstance().parse(retObjectTruncate_ToString);
                    return retObjectTruncateNumber.doubleValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportTruncateError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into double and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectTruncate != null ? retObjectTruncate.getClass() : "null", retObjectTruncate_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportTruncateError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static short Abs(short value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.OverflowException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value);
            return (short)retObjectAbs;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAbsError = true;
            java.lang.String retObjectAbs_ToString = retObjectAbs == null ? "null" : retObjectAbs.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAbs != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAbsClass = retObjectAbs.getClass();
                    // java.lang.reflect.Method retObjectAbsMethod = retObjectAbsClass.getMethod("shortValue");
                    // return (short)retObjectAbsMethod.invoke(retObjectAbs);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAbsNumber = java.text.NumberFormat.getInstance().parse(retObjectAbs_ToString);
                    return retObjectAbsNumber.shortValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAbsError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into short and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAbs != null ? retObjectAbs.getClass() : "null", retObjectAbs_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAbsError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static short Clamp(short value, short min, short max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value, min, max);
            return (short)retObjectClamp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportClampError = true;
            java.lang.String retObjectClamp_ToString = retObjectClamp == null ? "null" : retObjectClamp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectClamp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectClampClass = retObjectClamp.getClass();
                    // java.lang.reflect.Method retObjectClampMethod = retObjectClampClass.getMethod("shortValue");
                    // return (short)retObjectClampMethod.invoke(retObjectClamp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectClampNumber = java.text.NumberFormat.getInstance().parse(retObjectClamp_ToString);
                    return retObjectClampNumber.shortValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportClampError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into short and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectClamp != null ? retObjectClamp.getClass() : "null", retObjectClamp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportClampError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static short Max(short val1, short val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1, val2);
            return (short)retObjectMax;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxError = true;
            java.lang.String retObjectMax_ToString = retObjectMax == null ? "null" : retObjectMax.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMax != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxClass = retObjectMax.getClass();
                    // java.lang.reflect.Method retObjectMaxMethod = retObjectMaxClass.getMethod("shortValue");
                    // return (short)retObjectMaxMethod.invoke(retObjectMax);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxNumber = java.text.NumberFormat.getInstance().parse(retObjectMax_ToString);
                    return retObjectMaxNumber.shortValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into short and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMax != null ? retObjectMax.getClass() : "null", retObjectMax_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static short Min(short val1, short val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1, val2);
            return (short)retObjectMin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinError = true;
            java.lang.String retObjectMin_ToString = retObjectMin == null ? "null" : retObjectMin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinClass = retObjectMin.getClass();
                    // java.lang.reflect.Method retObjectMinMethod = retObjectMinClass.getMethod("shortValue");
                    // return (short)retObjectMinMethod.invoke(retObjectMin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinNumber = java.text.NumberFormat.getInstance().parse(retObjectMin_ToString);
                    return retObjectMinNumber.shortValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into short and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMin != null ? retObjectMin.getClass() : "null", retObjectMin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Abs(int value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.OverflowException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value);
            return (int)retObjectAbs;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAbsError = true;
            java.lang.String retObjectAbs_ToString = retObjectAbs == null ? "null" : retObjectAbs.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAbs != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAbsClass = retObjectAbs.getClass();
                    // java.lang.reflect.Method retObjectAbsMethod = retObjectAbsClass.getMethod("intValue");
                    // return (int)retObjectAbsMethod.invoke(retObjectAbs);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAbsNumber = java.text.NumberFormat.getInstance().parse(retObjectAbs_ToString);
                    return retObjectAbsNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAbsError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAbs != null ? retObjectAbs.getClass() : "null", retObjectAbs_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAbsError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Clamp(int value, int min, int max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value, min, max);
            return (int)retObjectClamp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportClampError = true;
            java.lang.String retObjectClamp_ToString = retObjectClamp == null ? "null" : retObjectClamp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectClamp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectClampClass = retObjectClamp.getClass();
                    // java.lang.reflect.Method retObjectClampMethod = retObjectClampClass.getMethod("intValue");
                    // return (int)retObjectClampMethod.invoke(retObjectClamp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectClampNumber = java.text.NumberFormat.getInstance().parse(retObjectClamp_ToString);
                    return retObjectClampNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportClampError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectClamp != null ? retObjectClamp.getClass() : "null", retObjectClamp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportClampError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int DivRem(int a, int b, JCORefOut<java.util.concurrent.atomic.AtomicInteger> result) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectDivRem = null;
        try {
            retObjectDivRem = classType.Invoke("DivRem", a, b, result.getJCRefOut());
            return (int)retObjectDivRem;
        } catch (java.lang.ClassCastException cce) {
            boolean reportDivRemError = true;
            java.lang.String retObjectDivRem_ToString = retObjectDivRem == null ? "null" : retObjectDivRem.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectDivRem != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectDivRemClass = retObjectDivRem.getClass();
                    // java.lang.reflect.Method retObjectDivRemMethod = retObjectDivRemClass.getMethod("intValue");
                    // return (int)retObjectDivRemMethod.invoke(retObjectDivRem);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectDivRemNumber = java.text.NumberFormat.getInstance().parse(retObjectDivRem_ToString);
                    return retObjectDivRemNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportDivRemError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectDivRem != null ? retObjectDivRem.getClass() : "null", retObjectDivRem_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportDivRemError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int ILogB(double x) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectILogB = null;
        try {
            retObjectILogB = classType.Invoke("ILogB", x);
            return (int)retObjectILogB;
        } catch (java.lang.ClassCastException cce) {
            boolean reportILogBError = true;
            java.lang.String retObjectILogB_ToString = retObjectILogB == null ? "null" : retObjectILogB.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectILogB != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectILogBClass = retObjectILogB.getClass();
                    // java.lang.reflect.Method retObjectILogBMethod = retObjectILogBClass.getMethod("intValue");
                    // return (int)retObjectILogBMethod.invoke(retObjectILogB);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectILogBNumber = java.text.NumberFormat.getInstance().parse(retObjectILogB_ToString);
                    return retObjectILogBNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportILogBError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectILogB != null ? retObjectILogB.getClass() : "null", retObjectILogB_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportILogBError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Max(int val1, int val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1, val2);
            return (int)retObjectMax;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxError = true;
            java.lang.String retObjectMax_ToString = retObjectMax == null ? "null" : retObjectMax.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMax != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxClass = retObjectMax.getClass();
                    // java.lang.reflect.Method retObjectMaxMethod = retObjectMaxClass.getMethod("intValue");
                    // return (int)retObjectMaxMethod.invoke(retObjectMax);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxNumber = java.text.NumberFormat.getInstance().parse(retObjectMax_ToString);
                    return retObjectMaxNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMax != null ? retObjectMax.getClass() : "null", retObjectMax_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Min(int val1, int val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1, val2);
            return (int)retObjectMin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinError = true;
            java.lang.String retObjectMin_ToString = retObjectMin == null ? "null" : retObjectMin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinClass = retObjectMin.getClass();
                    // java.lang.reflect.Method retObjectMinMethod = retObjectMinClass.getMethod("intValue");
                    // return (int)retObjectMinMethod.invoke(retObjectMin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinNumber = java.text.NumberFormat.getInstance().parse(retObjectMin_ToString);
                    return retObjectMinNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMin != null ? retObjectMin.getClass() : "null", retObjectMin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(double value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.IndexOutOfRangeException, system.RankException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.ArithmeticException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value);
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(short value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value);
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(int value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value);
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(long value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value);
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(SByte value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value == null ? null : value.getJCOInstance());
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(Single value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.IndexOutOfRangeException, system.RankException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.ArithmeticException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value == null ? null : value.getJCOInstance());
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static int Sign(Decimal value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectSign = null;
        try {
            retObjectSign = classType.Invoke("Sign", value == null ? null : value.getJCOInstance());
            return (int)retObjectSign;
        } catch (java.lang.ClassCastException cce) {
            boolean reportSignError = true;
            java.lang.String retObjectSign_ToString = retObjectSign == null ? "null" : retObjectSign.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectSign != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectSignClass = retObjectSign.getClass();
                    // java.lang.reflect.Method retObjectSignMethod = retObjectSignClass.getMethod("intValue");
                    // return (int)retObjectSignMethod.invoke(retObjectSign);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectSignNumber = java.text.NumberFormat.getInstance().parse(retObjectSign_ToString);
                    return retObjectSignNumber.intValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportSignError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into int and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectSign != null ? retObjectSign.getClass() : "null", retObjectSign_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportSignError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long Abs(long value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.OverflowException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value);
            return (long)retObjectAbs;
        } catch (java.lang.ClassCastException cce) {
            boolean reportAbsError = true;
            java.lang.String retObjectAbs_ToString = retObjectAbs == null ? "null" : retObjectAbs.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectAbs != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectAbsClass = retObjectAbs.getClass();
                    // java.lang.reflect.Method retObjectAbsMethod = retObjectAbsClass.getMethod("longValue");
                    // return (long)retObjectAbsMethod.invoke(retObjectAbs);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectAbsNumber = java.text.NumberFormat.getInstance().parse(retObjectAbs_ToString);
                    return retObjectAbsNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportAbsError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectAbs != null ? retObjectAbs.getClass() : "null", retObjectAbs_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportAbsError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long BigMul(int a, int b) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectBigMul = null;
        try {
            retObjectBigMul = classType.Invoke("BigMul", a, b);
            return (long)retObjectBigMul;
        } catch (java.lang.ClassCastException cce) {
            boolean reportBigMulError = true;
            java.lang.String retObjectBigMul_ToString = retObjectBigMul == null ? "null" : retObjectBigMul.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectBigMul != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectBigMulClass = retObjectBigMul.getClass();
                    // java.lang.reflect.Method retObjectBigMulMethod = retObjectBigMulClass.getMethod("longValue");
                    // return (long)retObjectBigMulMethod.invoke(retObjectBigMul);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectBigMulNumber = java.text.NumberFormat.getInstance().parse(retObjectBigMul_ToString);
                    return retObjectBigMulNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportBigMulError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectBigMul != null ? retObjectBigMul.getClass() : "null", retObjectBigMul_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportBigMulError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long BigMul(long a, long b, JCORefOut<java.util.concurrent.atomic.AtomicLong> low) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectBigMul = null;
        try {
            retObjectBigMul = classType.Invoke("BigMul", a, b, low.getJCRefOut());
            return (long)retObjectBigMul;
        } catch (java.lang.ClassCastException cce) {
            boolean reportBigMulError = true;
            java.lang.String retObjectBigMul_ToString = retObjectBigMul == null ? "null" : retObjectBigMul.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectBigMul != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectBigMulClass = retObjectBigMul.getClass();
                    // java.lang.reflect.Method retObjectBigMulMethod = retObjectBigMulClass.getMethod("longValue");
                    // return (long)retObjectBigMulMethod.invoke(retObjectBigMul);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectBigMulNumber = java.text.NumberFormat.getInstance().parse(retObjectBigMul_ToString);
                    return retObjectBigMulNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportBigMulError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectBigMul != null ? retObjectBigMul.getClass() : "null", retObjectBigMul_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportBigMulError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long Clamp(long value, long min, long max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value, min, max);
            return (long)retObjectClamp;
        } catch (java.lang.ClassCastException cce) {
            boolean reportClampError = true;
            java.lang.String retObjectClamp_ToString = retObjectClamp == null ? "null" : retObjectClamp.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectClamp != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectClampClass = retObjectClamp.getClass();
                    // java.lang.reflect.Method retObjectClampMethod = retObjectClampClass.getMethod("longValue");
                    // return (long)retObjectClampMethod.invoke(retObjectClamp);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectClampNumber = java.text.NumberFormat.getInstance().parse(retObjectClamp_ToString);
                    return retObjectClampNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportClampError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectClamp != null ? retObjectClamp.getClass() : "null", retObjectClamp_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportClampError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long DivRem(long a, long b, JCORefOut<java.util.concurrent.atomic.AtomicLong> result) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectDivRem = null;
        try {
            retObjectDivRem = classType.Invoke("DivRem", a, b, result.getJCRefOut());
            return (long)retObjectDivRem;
        } catch (java.lang.ClassCastException cce) {
            boolean reportDivRemError = true;
            java.lang.String retObjectDivRem_ToString = retObjectDivRem == null ? "null" : retObjectDivRem.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectDivRem != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectDivRemClass = retObjectDivRem.getClass();
                    // java.lang.reflect.Method retObjectDivRemMethod = retObjectDivRemClass.getMethod("longValue");
                    // return (long)retObjectDivRemMethod.invoke(retObjectDivRem);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectDivRemNumber = java.text.NumberFormat.getInstance().parse(retObjectDivRem_ToString);
                    return retObjectDivRemNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportDivRemError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectDivRem != null ? retObjectDivRem.getClass() : "null", retObjectDivRem_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportDivRemError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long Max(long val1, long val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1, val2);
            return (long)retObjectMax;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMaxError = true;
            java.lang.String retObjectMax_ToString = retObjectMax == null ? "null" : retObjectMax.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMax != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMaxClass = retObjectMax.getClass();
                    // java.lang.reflect.Method retObjectMaxMethod = retObjectMaxClass.getMethod("longValue");
                    // return (long)retObjectMaxMethod.invoke(retObjectMax);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMaxNumber = java.text.NumberFormat.getInstance().parse(retObjectMax_ToString);
                    return retObjectMaxNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMaxError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMax != null ? retObjectMax.getClass() : "null", retObjectMax_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMaxError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static long Min(long val1, long val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1, val2);
            return (long)retObjectMin;
        } catch (java.lang.ClassCastException cce) {
            boolean reportMinError = true;
            java.lang.String retObjectMin_ToString = retObjectMin == null ? "null" : retObjectMin.toString();
            try {
                if (!org.mases.jcobridge.netreflection.JCOReflector.getFallbackOnNativeParse()) {
                    throw new java.lang.RuntimeException("Application encountered an exception currently not managed since FallbackOnNativeParse is false. To automatically try to manage this kind of conditions use JCOReflector.setFallbackOnNativeParse and set the value to true; in any case you can opt-in to open an issue on GitHub.");
                }
                if (retObjectMin != null) {
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453728706
                    // java.lang.Class<?> retObjectMinClass = retObjectMin.getClass();
                    // java.lang.reflect.Method retObjectMinMethod = retObjectMinClass.getMethod("longValue");
                    // return (long)retObjectMinMethod.invoke(retObjectMin);

                    // https://github.com/masesgroup/JCOReflector/issues/246#issuecomment-3281199723
                    // https://github.com/masesgroup/JCOReflector/issues/253#issuecomment-3453924465
                    java.lang.Number retObjectMinNumber = java.text.NumberFormat.getInstance().parse(retObjectMin_ToString);
                    return retObjectMinNumber.longValue();
                }
                else throw new java.lang.NullPointerException("Return value is null and this is not expected");
            } catch (java.lang.Exception cceInner) {
                reportMinError = false;
                throw new java.lang.IllegalStateException(java.lang.String.format("Failed to convert %s (%s) into long and, as fallback solution, using java.lang.Number with exception %s (%s)", retObjectMin != null ? retObjectMin.getClass() : "null", retObjectMin_ToString, cceInner.getClass(), cceInner.getMessage()), cce);
            }
            finally {
                if (reportMinError) {
                    java.lang.System.err.println("Output returned from a fallback solution.");
                }
            }
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static SByte Abs(SByte value) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException, system.OverflowException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value == null ? null : value.getJCOInstance());
            JCObject objAbs = (JCObject)retObjectAbs;
            return new SByte(objAbs);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectAbs != null ? retObjectAbs.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static SByte Clamp(SByte value, SByte min, SByte max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new SByte(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static SByte Max(SByte val1, SByte val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new SByte(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static SByte Min(SByte val1, SByte val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new SByte(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Single Abs(Single value) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value == null ? null : value.getJCOInstance());
            JCObject objAbs = (JCObject)retObjectAbs;
            return new Single(objAbs);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectAbs != null ? retObjectAbs.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Single Clamp(Single value, Single min, Single max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new Single(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Single Max(Single val1, Single val2) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new Single(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Single Min(Single val1, Single val2) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new Single(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Abs(Decimal value) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectAbs = null;
        try {
            retObjectAbs = classType.Invoke("Abs", value == null ? null : value.getJCOInstance());
            JCObject objAbs = (JCObject)retObjectAbs;
            return new Decimal(objAbs);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectAbs != null ? retObjectAbs.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Ceiling(Decimal d) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectCeiling = null;
        try {
            retObjectCeiling = classType.Invoke("Ceiling", d == null ? null : d.getJCOInstance());
            JCObject objCeiling = (JCObject)retObjectCeiling;
            return new Decimal(objCeiling);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectCeiling != null ? retObjectCeiling.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Clamp(Decimal value, Decimal min, Decimal max) throws Throwable, system.NotSupportedException, system.InvalidOperationException, system.ArgumentException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new Decimal(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Floor(Decimal d) throws Throwable, system.ArgumentException, system.NotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectFloor = null;
        try {
            retObjectFloor = classType.Invoke("Floor", d == null ? null : d.getJCOInstance());
            JCObject objFloor = (JCObject)retObjectFloor;
            return new Decimal(objFloor);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectFloor != null ? retObjectFloor.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Max(Decimal val1, Decimal val2) throws Throwable, system.NotSupportedException, system.InvalidOperationException, system.ArgumentException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new Decimal(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Min(Decimal val1, Decimal val2) throws Throwable, system.NotSupportedException, system.InvalidOperationException, system.ArgumentException, system.ArgumentOutOfRangeException, system.PlatformNotSupportedException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new Decimal(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Round(Decimal d, int decimals, MidpointRounding mode) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.ObjectDisposedException, system.RankException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", d == null ? null : d.getJCOInstance(), decimals, mode == null ? null : mode.getJCOInstance());
            JCObject objRound = (JCObject)retObjectRound;
            return new Decimal(objRound);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectRound != null ? retObjectRound.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Round(Decimal d, int decimals) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.ObjectDisposedException, system.RankException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", d == null ? null : d.getJCOInstance(), decimals);
            JCObject objRound = (JCObject)retObjectRound;
            return new Decimal(objRound);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectRound != null ? retObjectRound.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Round(Decimal d, MidpointRounding mode) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.ObjectDisposedException, system.RankException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", d == null ? null : d.getJCOInstance(), mode == null ? null : mode.getJCOInstance());
            JCObject objRound = (JCObject)retObjectRound;
            return new Decimal(objRound);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectRound != null ? retObjectRound.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Round(Decimal d) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.ObjectDisposedException, system.RankException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectRound = null;
        try {
            retObjectRound = classType.Invoke("Round", d == null ? null : d.getJCOInstance());
            JCObject objRound = (JCObject)retObjectRound;
            return new Decimal(objRound);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectRound != null ? retObjectRound.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static Decimal Truncate(Decimal d) throws Throwable, system.NotSupportedException, system.ArgumentException, system.PlatformNotSupportedException, system.InvalidOperationException, system.ArgumentOutOfRangeException, system.IndexOutOfRangeException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectTruncate = null;
        try {
            retObjectTruncate = classType.Invoke("Truncate", d == null ? null : d.getJCOInstance());
            JCObject objTruncate = (JCObject)retObjectTruncate;
            return new Decimal(objTruncate);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectTruncate != null ? retObjectTruncate.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt16 Clamp(UInt16 value, UInt16 min, UInt16 max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new UInt16(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt16 Max(UInt16 val1, UInt16 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new UInt16(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt16 Min(UInt16 val1, UInt16 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new UInt16(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new UInt32(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt32 Max(UInt32 val1, UInt32 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new UInt32(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt32 Min(UInt32 val1, UInt32 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new UInt32(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt64 BigMul(UInt64 a, UInt64 b, JCORefOut<UInt64> low) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectBigMul = null;
        try {
            retObjectBigMul = classType.Invoke("BigMul", a == null ? null : a.getJCOInstance(), b == null ? null : b.getJCOInstance(), low.getJCRefOut());
            JCObject objBigMul = (JCObject)retObjectBigMul;
            return new UInt64(objBigMul);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectBigMul != null ? retObjectBigMul.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt64 Clamp(UInt64 value, UInt64 min, UInt64 max) throws Throwable, system.ArgumentException, system.ArgumentOutOfRangeException, system.ArgumentNullException, system.InvalidOperationException, system.PlatformNotSupportedException, system.ArrayTypeMismatchException, system.NotSupportedException, system.globalization.CultureNotFoundException, system.ObjectDisposedException {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectClamp = null;
        try {
            retObjectClamp = classType.Invoke("Clamp", value == null ? null : value.getJCOInstance(), min == null ? null : min.getJCOInstance(), max == null ? null : max.getJCOInstance());
            JCObject objClamp = (JCObject)retObjectClamp;
            return new UInt64(objClamp);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectClamp != null ? retObjectClamp.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt64 Max(UInt64 val1, UInt64 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMax = null;
        try {
            retObjectMax = classType.Invoke("Max", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMax = (JCObject)retObjectMax;
            return new UInt64(objMax);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMax != null ? retObjectMax.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }

    public static UInt64 Min(UInt64 val1, UInt64 val2) throws Throwable {
        if (classType == null)
            throw new java.lang.UnsupportedOperationException("classType is null.");
        java.lang.Object retObjectMin = null;
        try {
            retObjectMin = classType.Invoke("Min", val1 == null ? null : val1.getJCOInstance(), val2 == null ? null : val2.getJCOInstance());
            JCObject objMin = (JCObject)retObjectMin;
            return new UInt64(objMin);
        } catch (java.lang.ClassCastException cce) {
            throw new java.lang.IllegalStateException(java.lang.String.format("Failed to cast %s into JCObject", retObjectMin != null ? retObjectMin.getClass() : "null"), cce);
        } catch (JCNativeException jcne) {
            throw translateException(jcne);
        }
    }


    
    // Properties section
    


    // Instance Events section
    

}